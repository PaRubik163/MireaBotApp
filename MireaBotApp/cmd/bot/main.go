package main

import (
	"github.com/joho/godotenv"
	"log"
	"os"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	handler "mireabot/internal/parser/bot"
	database "mireabot/internal/parser/bot/storage"
)

type UserState struct {
	login            string
	password         string
	awaitingLogin    bool
	awaitingPassword bool
}

var userStates = make(map[int64]*UserState)

func main() {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ .env —Ñ–∞–π–ª–∞")
	}

	botToken := os.Getenv("BOT_TOKEN")

	if botToken == "" {
		log.Fatal("Short BotToken")
	}

	bot, err := tgbotapi.NewBotAPI(botToken)
	bot.Debug = true
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("–ë–æ—Ç %s –∑–∞–ø—É—â–µ–Ω", bot.Self.UserName)

	u := tgbotapi.NewUpdate(0)
	u.Timeout = 60

	updates := bot.GetUpdatesChan(u)

	for update := range updates {

		// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—Ç–µ–∫—Å—Ç)
		if update.Message != nil {
			chatID := update.Message.Chat.ID
			text := update.Message.Text

			// –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–æ–≤—ã–π ‚Äî —Å–æ–∑–¥–∞—ë–º –¥–ª—è –Ω–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
			if _, exists := userStates[chatID]; !exists {
				userStates[chatID] = &UserState{}
			}
			user := userStates[chatID]

			switch {
			case user.awaitingLogin:
				user.login = text
				user.awaitingLogin = false
				user.awaitingPassword = true

				bot.Send(tgbotapi.NewMessage(chatID, "üîí –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å:"))

			case user.awaitingPassword:
				user.password = text
				user.awaitingPassword = false

				//// –í—ã–∑—ã–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
				if handler.HandlerLogin(bot, update.Message, user.login, user.password) {
					database.Insert(update.Message.From.UserName, user.login, user.password)
				} else {
					errButton := tgbotapi.NewInlineKeyboardButtonData("–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â—ë —Ä–∞–∑", "login")
					row := tgbotapi.NewInlineKeyboardRow(errButton)
					keyboard := tgbotapi.NewInlineKeyboardMarkup(row)

					reply := tgbotapi.NewMessage(update.Message.Chat.ID, "‚ùå–û–®–ò–ë–ö–ê –ê–í–¢–û–†–ò–ó–ê–¶–ò–ò\n\nü§î–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å\nüôè–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑")
					reply.ReplyMarkup = keyboard

					if _, err := bot.Send(reply); err != nil {
						log.Fatalf("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏", err)
					}
				}

			case text == "/start":
				handler.SendStartButtons(bot, chatID)

			default:
				bot.Send(tgbotapi.NewMessage(chatID, "–ù–∞–ø–∏—à–∏ /start –∏–ª–∏ –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É"))
			}
		}

		// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ –∫–Ω–æ–ø–∫–∏
		if update.CallbackQuery != nil {
			callback := update.CallbackQuery
			chatID := callback.Message.Chat.ID

			if _, exists := userStates[chatID]; !exists {
				userStates[chatID] = &UserState{}
			}
			user := userStates[chatID]

			switch callback.Data {
			case "login":
				database.InitDB()
				if !database.IsExists(callback.From.UserName) {
					user.awaitingLogin = true
					bot.Send(tgbotapi.NewMessage(chatID, "üîë–í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏–Ω –ú–ò–†–≠–ê:"))
				} else {
					l, p := database.Select(callback.From.UserName)
					handler.HandlerLogin(bot, callback.Message, l, p)
				}

			default:
				bot.Send(tgbotapi.NewMessage(chatID, "–ù–µ–ø–æ–Ω—è—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ"))
			}

			bot.Request(tgbotapi.NewCallback(callback.ID, ""))
		}
	}
}
